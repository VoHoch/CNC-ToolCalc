"""Writer for Fusion 360 .tools files."""

import json
import zipfile
from pathlib import Path
from typing import List
import logging
from ..models import Tool, Preset

logger = logging.getLogger(__name__)


class ToolsWriter:
    """Writes .tools files (Fusion 360 format).

    NOTE: This is a basic implementation. For production use with
    FusionToolsBuilder library, see integration instructions in handover docs.
    """

    def write_tools_file(self, tools: List[Tool], output_path: Path) -> None:
        """Write tools to .tools file.

        Args:
            tools: List of Tool objects with presets
            output_path: Output file path

        Raises:
            ValueError: If validation fails
        """
        logger.info(f"Writing {len(tools)} tools to: {output_path}")
        for tool in tools:
            logger.info(f"  - {tool.tool_id} (number={tool.number}, description={tool.description[:50]}, presets={len(tool.presets)})")

        # Convert tools to JSON format
        tool_library = self._build_tool_library(tools)

        # Validate all presets have 13 expressions
        self._validate_presets(tools)

        # Write to ZIP file
        try:
            with zipfile.ZipFile(output_path, "w", zipfile.ZIP_DEFLATED) as zf:
                # Write main tool library JSON
                # Use "tools.json" as filename (compatible with Fusion 360)
                json_data = json.dumps(tool_library, indent=2, ensure_ascii=False)
                zf.writestr("tools.json", json_data)

            logger.info(f"Successfully wrote .tools file: {output_path}")

        except Exception as e:
            logger.error(f"Failed to write .tools file: {e}")
            raise

    def _build_tool_library(self, tools: List[Tool]) -> dict:
        """Build tool library JSON structure.

        Args:
            tools: List of Tool objects

        Returns:
            Tool library dictionary
        """
        return {
            "version": 16,
            "name": "CNC Calculator Export",
            "description": "Generated by CNC Schnittwerte Calculator",
            "data": [self._tool_to_dict(tool) for tool in tools],
        }

    def _tool_to_dict(self, tool: Tool) -> dict:
        """Convert Tool object to Fusion 360 JSON format.

        Args:
            tool: Tool object

        Returns:
            Tool dictionary
        """
        # CRITICAL FIX: Use raw_data if available for 1:1 export
        # This preserves ALL original fields (geometry, holder, post-process, etc.)
        # Only replace "start-values" with calculated presets
        if tool.raw_data:
            logger.debug(f"Tool {tool.tool_id}: Using raw tool data (1:1 export of all fields)")
            tool_dict = tool.raw_data.copy()  # Start with original data

            # Only replace start-values with calculated presets
            if tool.presets:
                # Sort presets alphabetically by name before export
                sorted_presets = sorted(tool.presets, key=lambda p: p.name)
                tool_dict["start-values"] = {
                    "presets": [self._preset_to_dict(preset) for preset in sorted_presets]
                }
            else:
                tool_dict["start-values"] = {
                    "presets": []
                }

            return tool_dict

        # Fallback: Manual construction (for tools created without import)
        tool_dict = {
            "guid": str(tool.guid),
            "type": tool.type.value,
            "unit": tool.unit,
            "BMC": tool.body_material_code,
            "description": tool.description,
            "vendor": tool.vendor,
            "product-id": tool.product_id,
            "product-link": tool.product_link,
            "grade": tool.grade,
            # Geometry
            "geometry": self._geometry_to_dict(tool),
            # Holder
            "holder": self._holder_to_dict(tool),
            # Post-process
            "post-process": self._post_process_to_dict(tool),
        }

        # CRITICAL FIX: Presets must be under "start-values" for Fusion 360
        # Add presets in Fusion 360 format (sorted alphabetically)
        if tool.presets:
            sorted_presets = sorted(tool.presets, key=lambda p: p.name)
            tool_dict["start-values"] = {
                "presets": [self._preset_to_dict(preset) for preset in sorted_presets]
            }
        else:
            tool_dict["start-values"] = {
                "presets": []
            }

        return tool_dict

    def _geometry_to_dict(self, tool: Tool) -> dict:
        """Convert geometry to dictionary.

        Args:
            tool: Tool object

        Returns:
            Geometry dictionary
        """
        geom = tool.geometry
        geom_dict = {
            "DC": geom.DC,
            "DCX": geom.DCX,
            "NOF": geom.NOF,
            "LCF": geom.LCF,
            "shoulder-diameter": geom.shoulder_diameter,
            "shoulder-length": geom.shoulder_length,
            "RE": geom.RE,
            "TA": geom.TA,
        }

        # Add optional fields if present
        if geom.OAL is not None:
            geom_dict["OAL"] = geom.OAL
        if geom.LB is not None:
            geom_dict["LB"] = geom.LB
        if geom.SFDM is not None:
            geom_dict["SFDM"] = geom.SFDM
        if geom.tip_angle is not None:
            geom_dict["tip-angle"] = geom.tip_angle

        return geom_dict

    def _holder_to_dict(self, tool: Tool) -> dict:
        """Convert holder to dictionary.

        Args:
            tool: Tool object

        Returns:
            Holder dictionary (preserves raw_data if available)
        """
        # CRITICAL FIX: Handle missing holder gracefully
        if not tool.holder:
            logger.warning(f"Tool {tool.tool_id} has no holder - exporting empty holder")
            return {
                "description": "",
                "vendor": "",
                "product-id": "",
                "product-link": "",
                "diameter": 0,
                "length": 0,
            }

        holder = tool.holder

        # CRITICAL FIX: Use raw_data if available for 1:1 export (preserves all Fusion 360 fields)
        # This includes: type, unit, gaugeLength, segments, guid, etc.
        if holder.raw_data:
            logger.debug(f"Tool {tool.tool_id}: Using raw holder data (preserves segments, type, etc.)")
            return holder.raw_data

        # Fallback: Basic holder export (for manually created tools without raw_data)
        return {
            "description": holder.description or "",
            "vendor": holder.vendor or "",
            "product-id": holder.product_id or "",
            "product-link": holder.product_link or "",
            "diameter": holder.diameter or 0,
            "length": holder.length or 0,
        }

    def _post_process_to_dict(self, tool: Tool) -> dict:
        """Convert post-process to dictionary.

        Args:
            tool: Tool object

        Returns:
            Post-process dictionary
        """
        pp = tool.post_process
        return {
            "comment": pp.comment,
            "number": pp.number,
            "diameter-offset": pp.diameter_offset,
            "length-offset": pp.length_offset,
            "manual-tool-change": pp.manual_tool_change,
            "break-control": pp.break_control,
            "clockwise": pp.clockwise,
        }

    def _preset_to_dict(self, preset: Preset) -> dict:
        """Convert preset to Fusion 360 format.

        Args:
            preset: Preset object

        Returns:
            Preset dictionary with expressions
        """
        # CRITICAL FIX: Add material filter so Fusion 360 can filter presets by material
        # Map our material IDs to Fusion 360 material categories
        material_query_map = {
            "Aluminium": "aluminum",
            "Steel": "steel",
            "Stainless": "stainless",
            "Hardwood": "hardwood",
            "Softwood": "softwood",
            "Plastic": "plastic",
            "Brass": "brass",
            "Copper": "copper",
        }

        # CRITICAL FIX: Match EXACT Fusion 360 format from original files
        # Based on analysis of actual Fusion 360 .tools files

        # USER REQUIREMENT: All values parametric via expressions EXCEPT v_c and f_z
        # v_c and f_z are base values (direct numeric)
        # All other values are expressions that reference these base values

        preset_dict = {
            "guid": str(preset.guid),
            "name": preset.name,
            "description": preset.comment,
            # Material filter
            "material": {
                "category": "all",
                "query": material_query_map.get(preset.material, ""),
                "use-hardness": False
            },
            # BASE VALUES (direct numeric - NOT parametric)
            "v_c": preset.vc_final,  # Base cutting speed [m/min]
            "f_z": preset.fz_final,  # Base feed per tooth [mm]

            # DERIVED VALUES (calculated from expressions - PARAMETRIC)
            # CRITICAL: For Fusion to recognize as parametric, top-level values must
            # be NUMERIC (not string references), but expressions dict must exist
            # Fusion links them automatically by matching expression name to field
            "n": preset.n_rpm,
            "n_ramp": preset.n_rpm,
            "f_n": preset.vf_mm_per_min / preset.n_rpm if preset.n_rpm > 0 else 0,
            "v_f": preset.vf_mm_per_min,
            "v_f_leadIn": preset.vf_mm_per_min * preset.feed_entry,
            "v_f_leadOut": preset.vf_mm_per_min * preset.feed_exit,
            "v_f_plunge": preset.vf_mm_per_min * preset.feed_plunge,
            "v_f_ramp": preset.vf_mm_per_min * preset.feed_ramp,
            "v_f_transition": preset.vf_mm_per_min * preset.feed_transition,
            # Stepdown/stepover: numeric values that Fusion will link to expressions
            "stepdown": preset.ap_mm,
            "stepover": preset.ae_mm,
            "use-stepdown": True,
            "use-stepover": True,
            "ramp-angle": float(preset.expressions.get("tool_rampAngle", "3.0 deg").split()[0]) if preset.expressions else 3.0,
            # CRITICAL: Coolant with hyphen!
            "tool-coolant": "disabled",

            # EXPRESSIONS - parametric formulas that user can adjust
            # All values except v_c and f_z are parametric
            "expressions": preset.expressions,
        }

        return preset_dict

    def _validate_presets(self, tools: List[Tool]) -> None:
        """Validate that all presets have required expressions.

        Args:
            tools: List of Tool objects

        Raises:
            ValueError: If any preset is missing expressions
        """
        for tool in tools:
            for preset in tool.presets:
                missing = preset.validate_expressions()
                if missing:
                    raise ValueError(
                        f"Tool {tool.tool_id}, Preset '{preset.name}': {missing[0]}"
                    )
